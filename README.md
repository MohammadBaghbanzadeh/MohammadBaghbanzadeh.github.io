<head>
  <link href="https://cdn.fontcdn.ir/Font/Persian/Vazir/Vazir.css" rel="stylesheet" type="text/css">
  
</head>

<div dir="rtl" align="right" style="padding: 0 60px;">

<p align="center" dir="rtl" style="font-weight: bold; font-size: 24px;">

# تحلیل سرشکن به روش پتانسیل (Potential Method)

## مقدمه: تحلیل سرشکن چیست؟

در تحلیل الگوریتم‌ها، گاهی هزینه اجرای یک عمل (Operation) در بدترین حالت (Worst Case) بسیار زیاد است، اما این حالت به ندرت اتفاق می‌افتد. اگر دنباله‌ای از `n` عمل را اجرا کنیم، هزینه کل ممکن است آنقدرها هم بد نباشد. **تحلیل سرشکن (Amortized Analysis)** به ما کمک می‌کند تا هزینه "متوسط" هر عمل را در طول یک دنباله از عملیات محاسبه کنیم، حتی اگر برخی از آن عملیات‌ها به تنهایی بسیار پرهزینه باشند.

نکته مهم این است که تحلیل سرشکن با تحلیل حالت متوسط (Average-Case Analysis) فرق دارد؛ در اینجا هیچ احتمالی در کار نیست و ما یک **تضمین** برای هزینه متوسط هر عمل در بدترین دنباله از عملیات ارائه می‌دهیم.

سه روش متداول برای تحلیل سرشکن وجود دارد:
1.  **روش تجمعی (Aggregate Analysis):** هزینه کل `n` عمل را `T(n)` محاسبه کرده و هزینه سرشکن هر عمل را `T(n)/n` در نظر می‌گیریم.
2.  **روش حسابداری (Accounting Method):** به هر عمل یک هزینه سرشکن اختصاص می‌دهیم. اگر این هزینه از هزینه واقعی بیشتر باشد، "اعتبار" (Credit) ذخیره می‌کنیم تا بعداً برای عملیات پرهزینه استفاده شود.
3.  **روش پتانسیل (Potential Method):** این روش که موضوع اصلی این بحث است، اعتبار را به صورت "انرژی پتانسیل" کل ساختمان داده در نظر می‌گیرد.

---

## روش پتانسیل (The Potential Method)

این روش، کار از پیش پرداخت شده (prepaid work) را به عنوان **انرژی پتانسیل** (`Φ`) در نظر می‌گیرد که می‌تواند برای پرداخت هزینه عملیات‌های بعدی آزاد شود. ما پتانسیل را به کل ساختمان داده نسبت می‌دهیم، نه به اشیاء خاص درون آن.

### تعاریف اصلی

-   فرض کنید `D₀` ساختمان داده اولیه ما باشد. ما دنباله‌ای از `n` عمل را روی آن انجام می‌دهیم.
-   `cᵢ` هزینه **واقعی** عمل `i`-ام است.
-   `Dᵢ` حالت ساختمان داده پس از انجام عمل `i`-ام روی `Dᵢ₋₁` است.
-   **تابع پتانسیل `Φ`**: این تابع هر حالت `Dᵢ` از ساختمان داده را به یک عدد حقیقی `Φ(Dᵢ)` نگاشت می‌کند. این عدد، پتانسیل آن حالت است.

**هزینه سرشکن (Amortized Cost)** عمل `i`-ام (`ĉᵢ`) به صورت زیر تعریف می‌شود:

```
ĉᵢ = cᵢ + Φ(Dᵢ) - Φ(Dᵢ₋₁)
```

بنابراین، هزینه سرشکن برابر است با هزینه واقعی به اضافه **تغییر در پتانسیل** ناشی از آن عمل.

-   اگر `Φ(Dᵢ) > Φ(Dᵢ₋₁)`، تغییر پتانسیل مثبت است. یعنی هزینه سرشکن `ĉᵢ` از هزینه واقعی `cᵢ` بیشتر است. ما ساختمان داده را "بیشتر شارژ" کرده‌ایم و پتانسیل آن را افزایش داده‌ایم.
-   اگر `Φ(Dᵢ) < Φ(Dᵢ₋₁)`، تغییر پتانسیل منفی است. یعنی هزینه سرشکن `ĉᵢ` از هزینه واقعی `cᵢ` کمتر است. کاهش پتانسیل، هزینه واقعی عمل را "پرداخت" می‌کند.

### هزینه سرشکن کل

هزینه سرشکن کل برای `n` عمل برابر است با:

```
Σ(ĉᵢ) [for i=1 to n] = Σ(cᵢ + Φ(Dᵢ) - Φ(Dᵢ₋₁)) [for i=1 to n]
```

این یک سری تلسکوپی است و نتیجه آن می‌شود:

```
Σ(ĉᵢ) = Σ(cᵢ) + Φ(Dₙ) - Φ(D₀)
```

برای اینکه هزینه سرشکن کل یک کران بالا (Upper Bound) برای هزینه واقعی کل باشد، باید داشته باشیم:

```
Φ(Dₙ) ≥ Φ(D₀)
```

در عمل، ما معمولاً `Φ(D₀) = 0` تعریف می‌کنیم و سپس نشان می‌دهیم که `Φ(Dᵢ) ≥ 0` برای تمام `i` ها. این کار تضمین می‌کند که پتانسیل هرگز منفی نمی‌شود و هزینه سرشکن کل همواره یک کران بالا برای هزینه واقعی کل است.

---

## مثال ۱: عملیات پشته (Stack)

یک پشته با سه عمل را در نظر بگیرید:
-   `PUSH(S, x)`: هزینه واقعی `cᵢ = 1`.
-   `POP(S)`: هزینه واقعی `cᵢ = 1`.
-   `MULTIPOP(S, k)`: `k` عنصر را برمی‌دارد. هزینه واقعی `cᵢ = min(k, s)` که `s` تعداد عناصر پشته است.

**تابع پتانسیل:** `Φ(D)` را برابر با **تعداد عناصر موجود در پشته** تعریف می‌کنیم.
برای یک پشته خالی اولیه `D₀`، داریم `Φ(D₀) = 0`. از آنجایی که تعداد عناصر پشته هرگز منفی نیست، `Φ(Dᵢ) ≥ 0` برای همه `i` ها.

**تحلیل هزینه‌ها:**

1.  **`PUSH`**:
    -   هزینه واقعی: `cᵢ = 1`.
    -   فرض کنید قبل از عمل، `s` عنصر در پشته وجود دارد. پس از `PUSH`، `s+1` عنصر خواهیم داشت.
    -   تغییر پتانسیل: `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = (s+1) - s = 1`.
    -   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ = 1 + 1 = 2`.

2.  **`POP`**:
    -   هزینه واقعی: `cᵢ = 1`.
    -   قبل از عمل `s` عنصر و بعد از آن `s-1` عنصر داریم.
    -   تغییر پتانسیل: `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = (s-1) - s = -1`.
    -   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ = 1 + (-1) = 0`.

3.  **`MULTIPOP(S, k)`**:
    -   هزینه واقعی: `cᵢ = k'` که `k' = min(k, s)`.
    -   قبل از عمل `s` عنصر و بعد از آن `s-k'` عنصر داریم.
    -   تغییر پتانسیل: `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = (s-k') - s = -k'`.
    -   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ = k' + (-k') = 0`.

**نتیجه:** هزینه سرشکن هر سه عمل `O(1)` است. بنابراین، هزینه کل یک دنباله از `n` عمل در بدترین حالت `O(n)` خواهد بود.

---

## مثال ۲: شمارنده دودویی (Binary Counter)

یک شمارنده `k`-بیتی را در نظر بگیرید که با عمل `INCREMENT` یکی به آن اضافه می‌شود. هزینه واقعی `INCREMENT` برابر با تعداد بیت‌هایی است که تغییر می‌کنند (از 1 به 0 یا از 0 به 1). در بدترین حالت (وقتی همه بیت‌ها 1 هستند)، هزینه `k` است.

**تابع پتانسیل:** `Φ(D)` را برابر با **تعداد بیت‌های 1 در شمارنده** تعریف می‌کنیم.

**تحلیل هزینه `INCREMENT`:**

-   فرض کنید عمل `i`-ام `INCREMENT` باعث می‌شود `tᵢ` بیت از 1 به 0 تغییر کنند (reset شوند).
-   این عمل حداکثر یک بیت را از 0 به 1 تغییر می‌دهد (set می‌کند).
-   پس هزینه واقعی: `cᵢ ≤ tᵢ + 1`.
-   فرض کنید `bᵢ` تعداد بیت‌های 1 پس از عمل `i`-ام باشد. `bᵢ₋₁` تعداد بیت‌های 1 قبل از آن است.
-   پس از ریست شدن `tᵢ` بیت و ست شدن حداکثر یک بیت، تعداد جدید بیت‌های 1 برابر است با: `bᵢ ≤ bᵢ₋₁ - tᵢ + 1`.
-   تغییر پتانسیل: `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = bᵢ - bᵢ₋₁ ≤ (bᵢ₋₁ - tᵢ + 1) - bᵢ₋₁ = 1 - tᵢ`.
-   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ ≤ (tᵢ + 1) + (1 - tᵢ) = 2`.

**نتیجه:** هزینه سرشکن عمل `INCREMENT` حداکثر 2، یعنی `O(1)` است. بنابراین هزینه `n` عمل `INCREMENT` برابر `O(n)` است.

---

## تمرین‌ها و مسائل حل شده (از CLRS)

در این بخش، چند تمرین از فصل ۱۷ کتاب CLRS را با استفاده از روش پتانسیل حل می‌کنیم.

### تمرین 17.3-1

**مسئله:** فرض کنید یک تابع پتانسیل `Φ` داریم که `Φ(Dᵢ) ≥ Φ(D₀)` برای تمام `i` ها، اما `Φ(D₀) ≠ 0`. نشان دهید یک تابع پتانسیل `'Φ` وجود دارد که `Φ'(D₀) = 0` و `Φ'(Dᵢ) ≥ 0` و هزینه‌های سرشکن با آن یکسان هستند.

**حل:**
تابع پتانسیل جدید را به صورت زیر تعریف می‌کنیم:
`Φ'(Dᵢ) = Φ(Dᵢ) - Φ(D₀)`

1.  **بررسی شرایط اولیه:**
    -   `Φ'(D₀) = Φ(D₀) - Φ(D₀) = 0`. شرط اول برقرار است.
    -   طبق فرض، `Φ(Dᵢ) ≥ Φ(D₀)` است، بنابراین `Φ(Dᵢ) - Φ(D₀) ≥ 0`. پس `Φ'(Dᵢ) ≥ 0` برای تمام `i` ها. شرط دوم نیز برقرار است.

2.  **بررسی هزینه سرشکن:**
    هزینه سرشکن جدید `ĉ'ᵢ` را محاسبه می‌کنیم:
    `ĉ'ᵢ = cᵢ + Φ'(Dᵢ) - Φ'(Dᵢ₋₁)`
    `ĉ'ᵢ = cᵢ + (Φ(Dᵢ) - Φ(D₀)) - (Φ(Dᵢ₋₁) - Φ(D₀))`
    `ĉ'ᵢ = cᵢ + Φ(Dᵢ) - Φ(D₀) - Φ(Dᵢ₋₁) + Φ(D₀)`
    `ĉ'ᵢ = cᵢ + Φ(Dᵢ) - Φ(Dᵢ₋₁)`
    این عبارت دقیقاً برابر با هزینه سرشکن قبلی (`ĉᵢ`) است. بنابراین هزینه‌های سرشکن یکسان باقی می‌مانند.

### تمرین 17.3-2 (بازحل تمرین 17.1-3)

**مسئله:** دنباله‌ای از `n` عمل را روی یک ساختمان داده انجام می‌دهیم. هزینه عمل `i`-ام برابر `i` است اگر `i` توانی دقیق از 2 باشد، و در غیر این صورت 1 است. از روش پتانسیل برای تعیین هزینه سرشکن هر عمل استفاده کنید.

**حل:**
می‌خواهیم یک هزینه سرشکن ثابت `ĉ` پیدا کنیم.
**تابع پتانسیل:** پتانسیل را طوری تعریف می‌کنیم که قبل از عملیات گران (وقتی `i` توان 2 است) به اندازه کافی انرژی ذخیره کرده باشیم.
`Φ(Dᵢ) = 2 * (i - 2^floor(log₂i))`
این تابع در واقع `2` ضربدر فاصله `i` از نزدیک‌ترین توان 2 کوچکتر یا مساوی آن است. `Φ(D₀)=0`.

**تحلیل هزینه‌ها:**

1.  **حالت اول: `i` توان دقیقی از 2 نیست.**
    -   هزینه واقعی: `cᵢ = 1`.
    -   در این حالت `floor(log₂(i-1)) = floor(log₂i)`. بگذارید `m = 2^floor(log₂i)`.
    -   `Φ(Dᵢ) = 2(i - m)`
    -   `Φ(Dᵢ₋₁) = 2((i-1) - m)`
    -   `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = 2(i-m) - 2(i-1-m) = 2`.
    -   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ = 1 + 2 = 3`.

2.  **حالت دوم: `i` توان دقیقی از 2 است.**
    -   هزینه واقعی: `cᵢ = i`.
    -   در این حالت `i = 2^log₂i`، بنابراین `i - 2^floor(log₂i) = 0`. پس `Φ(Dᵢ) = 0`.
    -   برای `i-1`، نزدیک‌ترین توان 2 کوچکتر، `i/2` است.
    -   `Φ(Dᵢ₋₁) = 2 * ((i-1) - 2^floor(log₂(i-1))) = 2 * ((i-1) - i/2) = 2 * (i/2 - 1) = i - 2`.
    -   `ΔΦ = Φ(Dᵢ) - Φ(Dᵢ₋₁) = 0 - (i - 2) = -i + 2`.
    -   هزینه سرشکن: `ĉᵢ = cᵢ + ΔΦ = i + (-i + 2) = 2`.

**نتیجه:** هزینه سرشکن هر عمل حداکثر 3 است، یعنی `O(1)`.

### تمرین 17.3-4

**مسئله:** هزینه واقعی کل اجرای `n` عمل پشته (PUSH, POP, MULTIPOP) چقدر است، با فرض اینکه پشته با `s₀` شیء شروع شده و با `sₙ` شیء تمام می‌شود؟

**حل:**
از فرمول اصلی هزینه کل استفاده می‌کنیم:
`Σcᵢ = Σĉᵢ - (Φ(Dₙ) - Φ(D₀))`

-   `Φ(D)` تعداد اشیاء در پشته است. پس `Φ(D₀) = s₀` و `Φ(Dₙ) = sₙ`.
-   هزینه سرشکن `PUSH` برابر 2 و برای `POP` و `MULTIPOP` برابر 0 است.
-   فرض کنید در دنباله `n` عمل، `n_push` عمل `PUSH` و `n_pop+n_multipop` عمل دیگر داشته باشیم.
-   هزینه سرشکن کل: `Σĉᵢ = 2 * n_push`.
-   جایگذاری در فرمول:
    `Σcᵢ = (2 * n_push) - (sₙ - s₀)`

این عبارت، هزینه واقعی کل را بر حسب تعداد `PUSH` ها و تعداد عناصر اولیه و نهایی بیان می‌کند.

### تمرین 17.3-5

**مسئله:** فرض کنید یک شمارنده با `b` بیت 1 شروع به کار می‌کند. نشان دهید هزینه `n` عمل `INCREMENT` برابر `O(n)` است اگر `n = Ω(b)`.

**حل:**
از تحلیل مثال شمارنده دودویی استفاده می‌کنیم.
-   هزینه واقعی کل: `Σcᵢ ≤ Σĉᵢ - (Φ(Dₙ) - Φ(D₀))`.
-   هزینه سرشکن هر `INCREMENT` حداکثر 2 بود. پس `Σĉᵢ ≤ 2n`.
-   `Φ(D)` تعداد بیت‌های 1 است.
-   `Φ(D₀) = b` (تعداد بیت‌های 1 در ابتدا).
-   `Φ(Dₙ) = bₙ` (تعداد بیت‌های 1 در انتها).
-   پس: `Σcᵢ ≤ 2n - (bₙ - b) = 2n - bₙ + b`.
-   از آنجایی که تعداد بیت‌های 1 هرگز منفی نیست، `bₙ ≥ 0`.
-   بنابراین: `Σcᵢ ≤ 2n + b`.
-   فرض مسئله این است که `n = Ω(b)`، یعنی `n` با نرخ `b` یا سریع‌تر رشد می‌کند. به عبارت دیگر، یک ثابت `c > 0` وجود دارد که `n ≥ c*b`، یا `b ≤ n/c`.
-   این را در نابرابری هزینه کل جایگذاری می‌کنیم:
    `Σcᵢ ≤ 2n + n/c = (2 + 1/c) * n`.
-   از آنجایی که `c` یک ثابت است، کل هزینه `O(n)` است.

موفق باشید!

</div>
